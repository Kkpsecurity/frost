import React from "react";
import { useEffect, useRef, useState } from "react";
import { Button } from "react-bootstrap";
import { ClassDataShape, StudentType } from "../../../../../../Config/types";
import CanvasComponent from "./CanvasComponent";
import VideoComponent from "./VideoComponent";
import { Logger } from "agora-rtc-sdk";
import { Spinner } from "react-bootstrap";

/**
 * ImageIDCapture Lets the user capture an image from the webcam
 * features:
 * - Capture image from webcam
 * - Reset the Webcam to capture another image
 * - Upload an image to the local file system
 */

interface ImageIDCaptureProps {
    data: ClassDataShape | null;
    student: StudentType;
    photoType: string | null;
    headshot: string | null;
    idcard: string | null;
    debug?: boolean;
}

const ImageIDCapture: React.FC<ImageIDCaptureProps> = ({
    data,
    student,
    photoType,
    headshot,
    idcard,
    debug = false,
}) => {
    console.log("ImageIDCapture", photoType, headshot, idcard, student);

    const [captured, setCaptured] = useState<boolean>(false);
    const [cameraStream, setCameraStream] = useState<MediaStream | null>(null);
    const [filesentTotserver, setFileSentToServer] = useState<boolean>(false);
    const [cameraError, setCameraError] = useState<string | null>(null);
    const [cameraLoading, setCameraLoading] = useState<boolean>(true);
    const videoRef = useRef(null);
    const canvasRef = useRef(null);

    const [loading, setLoading] = useState<boolean>(false);

    const [dimensions, setDimensions] = useState(
        window.innerWidth > 768
            ? { width: 400, height: 300 }
            : { width: 320, height: 280 }
    );

    useEffect(() => {
        const handleResize = () => {
            setDimensions(
                window.innerWidth > 768
                    ? { width: 400, height: 300 }
                    : { width: 320, height: 280 }
            );
        };

        // Attach the event listener
        window.addEventListener('resize', handleResize);

        // Cleanup the event listener on component unmount
        return () => {
            window.removeEventListener('resize', handleResize);
        };
    }, []);

    /**
     * Reset the webcam with improved error handling
     */
    const handleWebcamReset = () => {
        if (cameraStream) {
            cameraStream.getTracks().forEach((track) => track.stop());
        }

        setCameraStream(null);
        setCaptured(false);
        setCameraError(null);
        enableCamera();

        if (canvasRef.current) {
            const canvas = canvasRef.current as HTMLCanvasElement;
            const context = canvas.getContext("2d");
            if (context) {
                context.clearRect(0, 0, canvas.width, canvas.height);
            }
        }
    };

    /**
     * Upload state
     */
    const [isLoading, setIsLoading] = useState(false);
    const [isError, setIsError] = useState(false);

    /**
     * Simple file upload function
     */
    const saveImage = async (formData: FormData) => {
        setIsLoading(true);
        setIsError(false);
        try {
            const response = await fetch('/api/upload-photo', {
                method: 'POST',
                body: formData,
            });

            if (!response.ok) {
                throw new Error('Upload failed');
            }

            return await response.json();
        } catch (error) {
            setIsError(true);
            throw error;
        } finally {
            setIsLoading(false);
        }
    };

    /**
     * Send File to server
     */
    const handleSaveImage = async () => {
        setLoading(true);
        try {
            // Convert canvas to blob
            const originalImageBlob = await new Promise<Blob>((resolve, reject) => {
                if (!canvasRef.current) {
                    reject(new Error("Canvas reference is null"));
                    return;
                }
                canvasRef.current.toBlob((blob) => {
                    if (blob) {
                        resolve(blob);
                    } else {
                        reject(new Error("Failed to convert canvas to Blob"));
                    }
                }, "image/png");
            });

            // Resize the image blob using a canvas
            const img = new Image();
            img.src = URL.createObjectURL(originalImageBlob);
            await new Promise((resolve, reject) => { // Add reject to handle image loading errors
                img.onload = () => resolve(null); // Resolve with null because onload doesn't return a value
                img.onerror = () => reject(new Error("Failed to load image for resizing")); // Handle image load errors
            });

            const elem = document.createElement('canvas');
            const scaleFactor = 0.5; // Adjust this value to change the size
            elem.width = img.width * scaleFactor;
            elem.height = img.height * scaleFactor;
            const ctx = elem.getContext('2d');
            if (!ctx) {
                throw new Error("Failed to get canvas context");
            }
            ctx.drawImage(img, 0, 0, elem.width, elem.height);

            const resizedImageBlob = await new Promise<Blob>((resolve) => {
                ctx.canvas.toBlob((blob) => {
                    if (blob) {
                        resolve(blob);
                    } else {
                        throw new Error("Failed to convert resized canvas to Blob");
                    }
                }, "image/png");
            });

            const formData = new FormData();
            formData.append("student_unit_id", data.student_unit_id.toString());
            formData.append("course_auth_id", student.course_auth_id.toString());
            formData.append("_token", document.querySelector('meta[name="csrf-token"]')?.getAttribute("content") ?? "");
            formData.append("photoType", photoType ?? "");
            formData.append("file", resizedImageBlob); // Use the resized blob

            await saveImage(formData); // Assuming saveImage is async, wait for it to complete
            setFileSentToServer(true);

            setTimeout(() => {
                handleWebcamReset();
                setLoading(false);
            }, 3000);
        } catch (error) {
            console.error("Error saving image:", error);
            setLoading(false); // Ensure loading state is reset on error
            // Adjust error handling as necessary. The original throw might not be appropriate depending on your error handling strategy.
        }
    };



    /**
     * Enable camera with improved error handling
     */
    async function enableCamera() {
        try {
            // Check if we're in a secure context (HTTPS or localhost)
            if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
                console.error("Camera access requires HTTPS or localhost");
                setCameraError("Camera access requires a secure connection (HTTPS). Please use the upload option instead.");
                return;
            }

            // Check if navigator.mediaDevices is available
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                console.error("Camera access not supported in this browser");
                setCameraError("Camera access not supported in this browser. Please use the upload option instead.");
                return;
            }

            // Request camera access with specific constraints
            const stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    width: { ideal: 640 },
                    height: { ideal: 480 },
                    facingMode: 'user'
                },
                audio: false,
            });

            setCameraStream(stream);
            setCameraLoading(false);
            setCameraError(null);

            if (videoRef.current) {
                videoRef.current.srcObject = stream;
            }
        } catch (error) {
            console.error("Camera access error:", error);
            setCameraLoading(false);
            
            // Provide specific error messages based on the error type
            if (error.name === 'NotAllowedError') {
                setCameraError("Camera permission denied. Please allow camera access and try again, or use the upload option.");
            } else if (error.name === 'NotFoundError') {
                setCameraError("No camera found. Please ensure you have a camera connected or use the upload option.");
            } else if (error.name === 'NotReadableError') {
                setCameraError("Camera is already in use by another application. Please close other applications and try again.");
            } else {
                setCameraError("Unable to access camera. Please try using the upload option instead.");
    useEffect(() => {
        enableCamera();
        return () => {
            if (cameraStream) {
                cameraStream.getTracks().forEach((track) => track.stop());
            }
        };
    }, []);

    // If there's a camera error, show error message with fallback options
    if (cameraError) {
        return (
            <div
                style={{
                    background: "rgba(231, 76, 60, 0.1)",
                    border: "1px solid #e74c3c",
                    borderRadius: "0.375rem",
                    padding: "1rem",
                    textAlign: "center" as const,
                    color: "#e74c3c"
                }}
            >
                <i className="fas fa-exclamation-triangle mb-2" style={{ fontSize: "1.5rem" }}></i>
                <h6 style={{ color: "#e74c3c", margin: "0.5rem 0" }}>Camera Access Issue</h6>
                <p style={{ fontSize: "0.9rem", margin: "0.5rem 0" }}>{cameraError}</p>
                <div className="d-flex gap-2 justify-content-center mt-2">
                    <Button
                        size="sm"
                        variant="outline-warning"
                        onClick={enableCamera}
                        disabled={cameraLoading}
                    >
                        {cameraLoading ? (
                            <>
                                <Spinner size="sm" className="me-1" />
                                Retrying...
                            </>
                        ) : (
                            "Try Again"
                        )}
                    </Button>
                    <Button
                        size="sm"
                        variant="outline-secondary"
                        onClick={() => window.location.reload()}
                    >
                        Refresh Page
                    </Button>
                </div>
                <p style={{ fontSize: "0.8rem", margin: "0.5rem 0 0", color: "#95a5a6" }}>
                    Consider using the "Upload Photo" option instead.
                </p>
            </div>
        );
    }

    // Show loading state while camera is initializing
    if (cameraLoading) {
        return (
            <div
                style={{
                    background: "#34495e",
                    borderRadius: "0.375rem",
                    padding: "2rem",
                    textAlign: "center" as const,
                    color: "#ecf0f1"
                }}
            >
                <Spinner animation="border" variant="light" className="mb-2" />
                <p style={{ margin: "0" }}>Initializing camera...</p>
            </div>
        );
    }
        if (canvasRef.current && videoRef.current) {
            canvasRef.current
                .getContext("2d")
                .drawImage(
                    videoRef.current,
                    0,
                    0,
                    dimensions.width,
                    dimensions.height
                );

            /**
             * Convert the canvas to a data url
             */
            const imageURL = canvasRef.current.toDataURL("image/png");
            setCaptured(true);

            if (debug === true)
                console.log("Image Captured Successfullt: ", imageURL);
        } else {
            if (debug === true) console.log("No canvas or video ref found");
        }
    };

    if(loading) {
        return (
            <div className="text-center">
                <Spinner animation="border" variant="light" />
                <p>Processing...</p>
            </div>
        );
    }

    return (
        <>
            {isLoading && (
                <div className="alert alert-info">Uploading image...</div>
            )}

            {isError && (
                <div className="alert alert-danger">Error uploading image</div>
            )}

            {filesentTotserver && !isError && (
                <div className="alert alert-success">
                    Image uploaded successfully
                </div>
            )}

            <CanvasComponent
                width={dimensions.width}
                height={dimensions.height}
                captured={captured}
                canvasRef={canvasRef}
                handleSaveImage={handleSaveImage}
                handleWebcamReset={handleWebcamReset}
                debug={debug}
            />

            {!captured ? (
                <>
                    <VideoComponent
                        width={dimensions.width}
                        height={dimensions.height}
                        videoRef={videoRef}
                        captureImage={captureImage}
                        handleWebcamReset={handleWebcamReset}
                        debug={debug}
                    />
                </>
            ) : (
                <></>
            )}
        </>
    );
};

export default ImageIDCapture;
